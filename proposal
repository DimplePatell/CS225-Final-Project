## Leading Question 
How can we utilize disjoint sets and binary trees as well as other structures in this class to create a procedurally generated room that could be used in a video game with a BFS traversal, Dijkstra's Alogrithm and ...?

## Dataset Acquisition

## Data Format
We will be using a social network of users dataset (twitch_gamers possibly) from the Stanford Database. We will be reading in the dataset as a file in one of the functions to create the BST of users. The users will represent enemies or obstacles in which the number of their followers will represent their difficulty level. The potential enemies will be stored in a binary search tree so it is easy to find enemies that are more or less difficult.  The total difficulty of the room will be the sum of the enemies present and it will be based on the size. The dataset is fairly large so we will be using a subset of it determined by a random number generator (decide the number of enemies/obstacles). This will also be used to determine the size of the room. 

## Data Correction
As blocks and enemies are generated per room, if the difficulty level of the room is too high due to a certain enemy, the difficulty level of that enemy will be adjusted to match the level of the room it is in. The enemies will be chosen randomly, then if the sum of the enemy difficulty does not equal the difficulty of the room we will pick the first enemy and make it less or more difficult be one level then the second and the rest of the list.  Once the list is done we will go through the list again.  We will keep doing this until the room is the correct difficulty. Our dataset may have more data then we want enemies so we will choose a random subset of our dataset based on followers and then scale their difficulty according to the number of followers. (Most enemies = most followers, least enemies = least followers) We will organize them into the tree based on these stats and then assign everyone a difficulty number
Our enemy and difficulty level data will be stored in a graph with the enemies (users) as the nodes and their difficulty levels (followers) as the weights. We will parse through the data, getting a number of enemies depending on the size of the maze chosen and scale the difficulty as described above. If an error occurs due to a null or empty value, we will skip over it. Any negative values, will also be skipped over as the difficulty levels will start from 0 and go up.

## Data Storage
We will assign blocks as objects with a type of either an enemy or an obstacle. As potential enemies will be stored in a binary search tree, each enemy generated will be represented as a node in the tree. An individual node will possess information regarding the difficulty level of the enemy which will be represented as an integer variable. Likewise, obstacles will also be stored with a set integer difficulty level. There will also be a variable tracking the number of enemies present which will be used to determine a room's difficulty level.

## Algorithm 
The data will be a series of blocks that make up the room to be generated.  Each block can either contain an enemy or an obstacle.  There will be l * w blocks where l is the length of the room and w is the width. There will be at least 2 doors in a room and there must be a path from one door to the other.
We will be using the disjoint lists data structure to generate a room with an entrance and an exit.  It will have obstacles and enemies with a path from one door having a path to all other doors.  This is similar to the algorithms in MP mazes as we will use a BFS traversal to form the room which is a maze. This part of the project will require a size for the room and an entrance location and it will output the completed room.  This should take O(n log n + m) time to complete n -1 unions and m finds.
The second part of the project will be to add enemies using the binary search tree data structure.  We will need to create a binary search tree based on the lists of enemies.  The binary search tree will be generated based on the difficulty of the enemy.  We will determine a difficulty for the room based on the size of the room.  The enemies will be generated randomly and then we will scale their difficulty to match the difficulty of the room using the binary search tree. The time it will take to find the correct enemy is O(logn).  This is the time it takes to find an element in a balanced binary search tree. The enemies will be placed on the shortest path to the exit.  We will find this path using Dijkstra's algorithm which finds the shortest path from one node to another.  The time complexity of this is O((v+e)logv) where v is the number of nodes and e is the number of edges.  In our case each node has up to 4 edges (directions you can travel) and l*w nodes.

## Timeline
    November 7 - November 13
        Select dataset and create basic project framework including methods, variables, and objects necessary for the program.
    
    November 14 - November 20
        Implement algorithm for obstacle generation and prepare for midpoint checkin with project mentor. If time permits, begin working on enemy generation.
    
    November 21 - November 27
        Continue working on enemy generation. Comment on code and improve code efficency as well as organization. If time permits, add more options regarding blocks, enemies, and overall room generation.
    
    November 28 - December 4
        Test code and fix any remaining bugs. Work on README.md in github and begin project report. Start recording for final project video.
    
    December 5 - December 8 
        Complete project write up and final project video.
