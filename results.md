-The output and correctness of each algorithm- You should summarize, visualize, or highlight some part of the full-scale run of each algorithm. Additionally, the report should briefly describe what tests you performed to confirm that each algorithm was working as intended.
BFS Traversal: In our project, we use the disjoint sets data structure to generate a room and use a BFS traversal to form a room as a maze with one entrance.  We have a width*height 2-D vector which we initialize to have no obstacles, then add a grid of obstacles to act as walls.  We do a BFS traversal to remove some of the obstacles acting as walls till we have a path with no cycles.  Then we remove some extra obstacles so there are multiple paths.  Because of the added grid to make a room if you call MakeRoom(w,h) the resulting room will have a width of (2*w-1) and a height of (2*h-1).  The exit is decided in the SolveRoom function, it is an x,y coordinate on the rightmost edge of the room.  
Dijkstra’s Algorithm: This algorithm was used to solve the maze. To visualize the maze itself, we have a draw room and draw room solution function that displays the room and its solution as a PNG. The room will have obstacles, enemies, an entrance, and an exit. In order to solve the maze, this algorithm calculates the distance between nodes using edge weights which may be 0, -1, or a certain difficulty level. As we go through each node, we mark it as visited. When a node is visited the distance is stored in a 2D solution vector, however, if a shorter path to that node is found the distance assigned will be updated. If this algorithm does not calculate a correct traversal of the maze, we will be able to see it go over an obstacle.
 Graphical Output of a Graph: This algorithm was probably the most fun to make.  We wanted a user-friendly way to show our room with the enemies and the obstacles.  We made pixel art for the obstacles to look like rocks and the enemies to look like ghosts.  It’s clear from the output photo that you can’t get through the big, black rocks (they take up the entire space), but you might be able to maneuver around a ghost.  The outline around the square that shares the color of the ghost, however, reminds you that you are entering a danger zone and you might get attacked. This represents how the edges around an enemy increase with the difficulty of that enemy.   
-The answer to your leading question- You should directly address your proposed leading question. How did you answer this question? What did you discover? If your project was ultimately unsuccessful, give a brief reflection about what worked and what you would do differently as a team.
Our proposed leading question asked: What is the best way to navigate a convention maze filled with enemies that are also popular twitch gamers? We answered this question by creating a room with a single entrance and exit along with randomly placed obstacles (cannot be passed through) and enemies (can be passed through with varying difficulties). Using Dijkstra’s algorithm, we calculate the different paths one could take to complete the maze. The path with the smallest weight is the best way to navigate a maze filled with enemies. One thing that was important to consider was that a shorter path didn’t necessarily mean a faster nor optimal maze traversal. The more an enemy is weighted, the harder it is to pass by that point in the maze. That would mean that that path would be less and less optimal traversal. There was also a variable of walking weight, if the walking weight was too high then taking more steps to completely avoid an enemy would not be the optimal solution.  
To display an unsolved room, we simply checked whether an object or enemy was present in each coordinate. Based on each condition, we then assigned the corresponding pixels their appropriate values. 
Creating a visual representation of a solved room took more consideration as we had to utilize the solution generated from Dijkstra’s Algorithm while also considering the path traveled through the room. To do this, we constructed a 2D vector tracking the position of each node that was previously accessed in the solution path. We then set the ending position of the room to -1 which signified that we had reached the end of the path. For each position within the solution path we colored the according pixels based on what direction the path was headed in with the color being assigned based on the difficulty level of the room. For horizontal and vertical lines, we scaled the coordinates by a factor of 10, and for corners, we drew half a line.
Once our code is run, we can see three different solutions for the same room.  They are colored based on walking weight. The first has a walking weight of 0 and is green, the second has a walking weight of 50 and is yellow, and the third has a walking weight of 100 and is red. This clearly shows that if you really don’t want to walk far, you won’t avoid as many enemies, but if you don’t care, you can avoid almost anything.  
So, to answer our question: What is the best way to navigate a convention maze filled with enemies that are also popular twitch streamers? It depends on how crowded the maze is with enemies and obstacles and how much you are willing to walk. So, the best way might be subjective, but there certainly is a solution if you are simply willing to look for it.  

